#include "hal_data.h"
#include "shravyaCONFIG.h"
#include "eegTYPES.h"
#include "semaphoresGLOBAL.h"

/* μT-Kernel 3.0 includes */
#include "mtk3_bsp2/include/tk/tkernel.h"
#include "mtk3_bsp2/include/sys/sysdef.h"

/* ✅ COMPLETE μT-Kernel 3.0 Type System - ESSENTIAL FOR TRON CONTEST */
#ifndef INT
typedef int INT;
#endif

#ifndef ER
typedef int ER;
#endif

#ifndef ID
typedef int ID;
#endif

#ifndef E_OK
#define E_OK (0)
#endif

/* Task Attributes */
#ifndef TA_HLNG
#define TA_HLNG (0x00000001U)
#endif

#ifndef TA_RNG3
#define TA_RNG3 (0x00000300U)
#endif

/* μT-Kernel Task Structure */
typedef struct {
    uint32_t tskatr;    // Task attributes
    void *task;         // Task entry point
    int itskpri;        // Task priority
    uint32_t stksz;     // Stack size
    void *stkadr;       // Stack address
} T_CTSK;

/* Function Prototypes */
extern ER tk_ini_ker(void);
extern ER tk_ext_ker(void);
extern ID tk_cre_tsk(T_CTSK *pk_ctsk);
extern ER tk_sta_tsk(ID tskid, INT stacd);
extern ER initialize_global_semaphores(void);

/* SHRAVYA Task Entry Points */
extern void task_eeg_acquisition_entry(INT stacd, void *exinf);
extern void task_signal_processing_entry(INT stacd, void *exinf);
extern void task_feature_extraction_entry(INT stacd, void *exinf);
extern void task_classification_entry(INT stacd, void *exinf);
extern void task_haptic_feedback_entry(INT stacd, void *exinf);
extern void task_communication_entry(INT stacd, void *exinf);
extern void task_shravya_main_entry(INT stacd, void *exinf);

/* SHRAVYA System Initialization */
extern fsp_err_t eeg_acquisition_init(void);
extern fsp_err_t signal_processing_init(void);
extern fsp_err_t cognitive_classifier_init(void);
extern fsp_err_t haptic_feedback_init(void);
extern fsp_err_t communication_init(void);
extern fsp_err_t power_management_init(void);

/* Task Stack Sizes */
#define TASK_STACK_SIZE_EEG       2048   // High-frequency data acquisition
#define TASK_STACK_SIZE_SIGNAL    2048   // FFT and signal processing
#define TASK_STACK_SIZE_FEATURE   1024   // Feature extraction
#define TASK_STACK_SIZE_CLASSIFY  2048   // Neural network inference
#define TASK_STACK_SIZE_HAPTIC    1024   // Motor control
#define TASK_STACK_SIZE_COMM      1024   // N8N communication
#define TASK_STACK_SIZE_MAIN      1024   // System coordinator

/* Global Task IDs */
static ID eeg_acquisition_task_id;
static ID signal_processing_task_id;
static ID feature_extraction_task_id;
static ID classification_task_id;
static ID haptic_feedback_task_id;
static ID communication_task_id;
static ID shravya_main_task_id;

/**
 * @brief Initialize SHRAVYA hardware subsystems
 */
static fsp_err_t shravya_hardware_init(void)
{
    fsp_err_t err;

    /* Initialize EEG acquisition hardware */
    err = eeg_acquisition_init();
    if (FSP_SUCCESS != err) return err;

    /* Initialize signal processing */
    err = signal_processing_init();
    if (FSP_SUCCESS != err) return err;

    /* Initialize haptic feedback hardware */
    err = haptic_feedback_init();
    if (FSP_SUCCESS != err) return err;

    /* Initialize communication */
    err = communication_init();
    if (FSP_SUCCESS != err) return err;

    /* Initialize power management */
    err = power_management_init();
    if (FSP_SUCCESS != err) return err;

    /* ✅ Test system ready notification */
    if (haptic_feedback_init() == FSP_SUCCESS) {
        trigger_system_ready();  // Brief vibration to indicate system ready
    }

    return FSP_SUCCESS;
}

/**
 * @brief Create and start μT-Kernel tasks
 */
static ER create_shravya_tasks(void)
{
    T_CTSK ctsk;
    ER ercd;

    /* 1. EEG Acquisition Task (Highest Priority) */
    ctsk.tskatr = TA_HLNG | TA_RNG3;
    ctsk.task = (void*)task_eeg_acquisition_entry;
    ctsk.itskpri = TASK_PRIORITY_EEG_ACQ;
    ctsk.stksz = TASK_STACK_SIZE_EEG;
    ctsk.stkadr = NULL;

    eeg_acquisition_task_id = tk_cre_tsk(&ctsk);
    if (eeg_acquisition_task_id <= 0) return E_SYS;

    ercd = tk_sta_tsk(eeg_acquisition_task_id, 0);
    if (ercd != E_OK) return ercd;

    /* 2. Signal Processing Task */
    ctsk.task = (void*)task_signal_processing_entry;
    ctsk.itskpri = TASK_PRIORITY_PREPROCESSING;
    ctsk.stksz = TASK_STACK_SIZE_SIGNAL;

    signal_processing_task_id = tk_cre_tsk(&ctsk);
    if (signal_processing_task_id <= 0) return E_SYS;

    ercd = tk_sta_tsk(signal_processing_task_id, 0);
    if (ercd != E_OK) return ercd;

    /* 3. Feature Extraction Task */
    ctsk.task = (void*)task_feature_extraction_entry;
    ctsk.itskpri = TASK_PRIORITY_FEATURE_EXTRACT;
    ctsk.stksz = TASK_STACK_SIZE_FEATURE;

    feature_extraction_task_id = tk_cre_tsk(&ctsk);
    if (feature_extraction_task_id <= 0) return E_SYS;

    ercd = tk_sta_tsk(feature_extraction_task_id, 0);
    if (ercd != E_OK) return ercd;

    /* 4. Cognitive Classification Task */
    ctsk.task = (void*)task_classification_entry;
    ctsk.itskpri = TASK_PRIORITY_CLASSIFICATION;
    ctsk.stksz = TASK_STACK_SIZE_CLASSIFY;

    classification_task_id = tk_cre_tsk(&ctsk);
    if (classification_task_id <= 0) return E_SYS;

    ercd = tk_sta_tsk(classification_task_id, 0);
    if (ercd != E_OK) return ercd;

    /* 5. Haptic Feedback Task */
    ctsk.task = (void*)task_haptic_feedback_entry;
    ctsk.itskpri = TASK_PRIORITY_HAPTIC;
    ctsk.stksz = TASK_STACK_SIZE_HAPTIC;

    haptic_feedback_task_id = tk_cre_tsk(&ctsk);
    if (haptic_feedback_task_id <= 0) return E_SYS;

    ercd = tk_sta_tsk(haptic_feedback_task_id, 0);
    if (ercd != E_OK) return ercd;

    /* 6. N8N Communication Task */
    ctsk.task = (void*)task_communication_entry;
    ctsk.itskpri = TASK_PRIORITY_COMMUNICATION;
    ctsk.stksz = TASK_STACK_SIZE_COMM;

    communication_task_id = tk_cre_tsk(&ctsk);
    if (communication_task_id <= 0) return E_SYS;

    ercd = tk_sta_tsk(communication_task_id, 0);
    if (ercd != E_OK) return ercd;

    /* 7. SHRAVYA Main Coordinator Task */
    ctsk.task = (void*)task_shravya_main_entry;
    ctsk.itskpri = 5;  // High priority system coordinator
    ctsk.stksz = TASK_STACK_SIZE_MAIN;

    shravya_main_task_id = tk_cre_tsk(&ctsk);
    if (shravya_main_task_id <= 0) return E_SYS;

    ercd = tk_sta_tsk(shravya_main_task_id, 0);
    if (ercd != E_OK) return ercd;

    return E_OK;
}

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/**
 * @brief SHRAVYA Main Entry Point - TRON Contest 2025
 * This is where μT-Kernel 3.0 and AI integration begins
 */
void hal_entry(void)
{
    ER ercd;

    /* FSP Hardware Initialization */
#if BSP_TZ_SECURE_BUILD
    R_BSP_NonSecureEnter();
#endif

    /* Initialize SHRAVYA Hardware Subsystems */
    if (shravya_hardware_init() != FSP_SUCCESS) {
        /* Hardware initialization failed - halt system */
        while(1) {
            __NOP();
        }
    }

    /* Initialize μT-Kernel 3.0 */
    ercd = tk_ini_ker();
    if (ercd != E_OK) {
        /* Kernel initialization failed */
        while(1) {
            __NOP();
        }
    }

    /* Create Global Semaphores for Task Coordination */
    ercd = initialize_global_semaphores();
    if (ercd != E_OK) {
        /* Semaphore creation failed */
        tk_ext_ker();
        while(1) {
            __NOP();
        }
    }

    /* Create and Start All SHRAVYA Tasks */
    ercd = create_shravya_tasks();
    if (ercd != E_OK) {
        /* Task creation failed */
        tk_ext_ker();
        while(1) {
            __NOP();
        }
    }

    /* ✅ CRITICAL: Start session notification */
    trigger_session_start();

    /* Start μT-Kernel 3.0 Scheduler - This should never return */
    tk_ext_ker();

    /* Should never reach here - system error */
    while(1) {
        __NOP();
    }
}

/**
 * @brief FSP Warm Start Handler
 */
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event) {
#if BSP_FEATURE_FLASH_LP_VERSION != 0
        R_FACI_LP->DFLCTL = 1U;
#endif
    }

    if (BSP_WARM_START_POST_C == event) {
        R_IOPORT_Open(&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD
FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable();
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable() {
}
FSP_CPP_FOOTER
#endif
