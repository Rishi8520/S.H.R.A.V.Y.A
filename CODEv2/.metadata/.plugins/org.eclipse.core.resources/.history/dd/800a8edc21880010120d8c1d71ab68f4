#include "hal_data.h"

/* μT-Kernel 3.0 includes - adjust path based on your mtk3_bsp2 location */
#include "mtk3_bsp2/include/tk/tkernel.h"
#include "mtk3_bsp2/include/tk/device.h"
#include "mtk3_bsp2/include/sys/sysdepend/tk_sysdepend.h"

/* SHRAVYA system includes */
#include "shravyaCONFIG.h"
#include "eegTYPES.h"

/* Function prototypes */
void shravya_system_init(void);
void shravya_start_application(void);
ER mtk3_kernel_init(void);

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/*******************************************************************************************************************//**
 * hal_entry() - Main entry point for SHRAVYA EEG System
 * Initializes FSP, μT-Kernel 3.0, and starts SHRAVYA application tasks
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t fsp_err = FSP_SUCCESS;
    ER kernel_err = E_OK;

    /* Step 1: Initialize SHRAVYA hardware subsystems */
    shravya_system_init();

    /* Step 2: Initialize μT-Kernel 3.0 */
    kernel_err = mtk3_kernel_init();
    if (kernel_err != E_OK)
    {
        /* Kernel initialization failed - handle error */
        while(1)
        {
            /* Flash error LED pattern */
            R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
            // Add LED error indication here
        }
    }

    /* Step 3: Start SHRAVYA application tasks */
    shravya_start_application();

    /* Step 4: Start μT-Kernel 3.0 scheduler - this should never return */
    tk_ext_ker();  // Extended kernel start

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code if using TrustZone */
    R_BSP_NonSecureEnter();
#endif

    /* Should never reach here if kernel is running properly */
    while(1)
    {
        __NOP();
    }
}

/*******************************************************************************************************************//**
 * shravya_system_init() - Initialize SHRAVYA hardware subsystems
 **********************************************************************************************************************/
void shravya_system_init(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Initialize I/O ports first */
    err = R_IOPORT_Open(&g_ioport_ctrl, &g_ioport_cfg);
    if (FSP_SUCCESS != err)
    {
        /* Handle I/O port initialization error */
        while(1); // Error trap
    }

    /* Initialize SPI for ADS1263 EEG ADC */
    err = R_SPI_Open(&g_spi0_ctrl, &g_spi0_cfg);
    if (FSP_SUCCESS != err)
    {
        /* Handle SPI initialization error */
        while(1); // Error trap
    }

    /* Initialize I2C for MAX17048 fuel gauge and other sensors */
    err = R_IIC_MASTER_Open(&g_i2c_master0_ctrl, &g_i2c_master0_cfg);
    if (FSP_SUCCESS != err)
    {
        /* Handle I2C initialization error */
        while(1); // Error trap
    }

    /* Initialize GPT timer for EEG sampling at 500Hz */
    err = R_GPT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    if (FSP_SUCCESS != err)
    {
        /* Handle timer initialization error */
        while(1); // Error trap
    }

    /* Set up 500Hz sampling period: 480MHz / (500Hz * prescaler) */
    uint32_t period_counts = (uint32_t)(480000000 / (500 * 1)); // Adjust prescaler as needed
    err = R_GPT_PeriodSet(&g_timer0_ctrl, period_counts);
    if (FSP_SUCCESS != err)
    {
        /* Handle timer period set error */
        while(1); // Error trap
    }

    /* Initialize ADC for internal monitoring (battery, temperature) */
    err = R_ADC_Open(&g_adc0_ctrl, &g_adc0_cfg);
    if (FSP_SUCCESS != err)
    {
        /* Handle ADC initialization error */
        while(1); // Error trap
    }

    /* Initialize external interrupt for ADS1263 DRDY signal */
    err = R_ICU_ExternalIrqOpen(&g_external_irq0_ctrl, &g_external_irq0_cfg);
    if (FSP_SUCCESS != err)
    {
        /* Handle external interrupt initialization error */
        while(1); // Error trap
    }

    /* Enable external interrupt for EEG data ready */
    err = R_ICU_ExternalIrqEnable(&g_external_irq0_ctrl);
    if (FSP_SUCCESS != err)
    {
        /* Handle external interrupt enable error */
        while(1); // Error trap
    }

    /* Initialize PWM for haptic motor control */
    err = R_GPT_Open(&g_timer1_ctrl, &g_timer1_cfg);  // Separate timer for PWM
    if (FSP_SUCCESS != err)
    {
        /* Handle PWM timer initialization error */
        while(1); // Error trap
    }
}

/*******************************************************************************************************************//**
 * mtk3_kernel_init() - Initialize μT-Kernel 3.0
 **********************************************************************************************************************/
ER mtk3_kernel_init(void)
{
    ER ercd = E_OK;

    /* Initialize μT-Kernel 3.0 system */
    ercd = tk_ini_ker();
    if (ercd != E_OK)
    {
        return ercd;
    }

    /* Set system configuration */
    ercd = tk_set_pow(NORMAL_SPEED);
    if (ercd != E_OK)
    {
        return ercd;
    }

    return E_OK;
}

/*******************************************************************************************************************//**
 * shravya_start_application() - Create and start SHRAVYA application tasks
 **********************************************************************************************************************/
void shravya_start_application(void)
{
    ER ercd = E_OK;
    ID task_id;
    T_CTSK ctsk;

    /* Task creation template */
    ctsk.tskatr = TA_HLNG | TA_RNG3;
    ctsk.stkadr = NULL;  // Auto stack allocation

    /* Create EEG Acquisition Task (Highest Priority) */
    ctsk.task = (FP)task_eeg_acquisition_entry;
    ctsk.itskpri = TASK_PRIORITY_EEG_ACQ;      // 10 (highest)
    ctsk.stksz = 2048;
    task_id = tk_cre_tsk(&ctsk);
    if (task_id > 0)
    {
        tk_sta_tsk(task_id, 0);  // Start task
    }

    /* Create Signal Processing Task */
    ctsk.task = (FP)task_preprocessing_entry;
    ctsk.itskpri = TASK_PRIORITY_PREPROCESSING; // 15
    ctsk.stksz = 2048;
    task_id = tk_cre_tsk(&ctsk);
    if (task_id > 0)
    {
        tk_sta_tsk(task_id, 0);
    }

    /* Create Feature Extraction Task */
    ctsk.task = (FP)task_feature_extraction_entry;
    ctsk.itskpri = TASK_PRIORITY_FEATURE_EXTRACT; // 20
    ctsk.stksz = 3072;
    task_id = tk_cre_tsk(&ctsk);
    if (task_id > 0)
    {
        tk_sta_tsk(task_id, 0);
    }

    /* Create AI Classification Task */
    ctsk.task = (FP)task_classification_entry;
    ctsk.itskpri = TASK_PRIORITY_CLASSIFICATION; // 25
    ctsk.stksz = 4096;
    task_id = tk_cre_tsk(&ctsk);
    if (task_id > 0)
    {
        tk_sta_tsk(task_id, 0);
    }

    /* Create Haptic Feedback Task */
    ctsk.task = (FP)task_haptic_feedback_entry;
    ctsk.itskpri = TASK_PRIORITY_HAPTIC;        // 30
    ctsk.stksz = 1024;
    task_id = tk_cre_tsk(&ctsk);
    if (task_id > 0)
    {
        tk_sta_tsk(task_id, 0);
    }

    /* Create Communication Task */
    ctsk.task = (FP)task_communication_entry;
    ctsk.itskpri = TASK_PRIORITY_COMMUNICATION; // 35 (lowest)
    ctsk.stksz = 2048;
    task_id = tk_cre_tsk(&ctsk);
    if (task_id > 0)
    {
        tk_sta_tsk(task_id, 0);
    }

    /* Create synchronization objects */
    T_CSEM csem = {TA_TFIFO, 0, 1};  // Binary semaphore
    tk_cre_sem(&csem);

    T_CMTX cmtx = {TA_TFIFO, 1};     // Mutex
    tk_cre_mtx(&cmtx);

    T_CFLG cflg = {TA_TFIFO | TA_WMUL, 0}; // Event flag
    tk_cre_flg(&cflg);
}

/*******************************************************************************************************************//**
 * R_BSP_WarmStart - BSP warm start callback (keep your existing implementation)
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0
        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;
        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }
    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */
        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, &g_ioport_cfg);

#if BSP_CFG_SDRAM_ENABLED
        /* Setup SDRAM and initialize it. Must configure pins first. */
        R_BSP_SdramInit(true);
#endif
    }
}

/* Forward declarations for task entry points - these will be implemented in separate files */
extern void task_eeg_acquisition_entry(INT stacd, void *exinf);
extern void task_preprocessing_entry(INT stacd, void *exinf);
extern void task_feature_extraction_entry(INT stacd, void *exinf);
extern void task_classification_entry(INT stacd, void *exinf);
extern void task_haptic_feedback_entry(INT stacd, void *exinf);
extern void task_communication_entry(INT stacd, void *exinf);

#if BSP_TZ_SECURE_BUILD
FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable();
/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable()
{
}
FSP_CPP_FOOTER
#endif
