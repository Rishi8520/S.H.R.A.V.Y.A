#include "hal_data.h"
#include "eegTYPES.h"
#include "shravyaCONFIG.h"
#include "mtk3_bsp2/include/tk/tkernel.h"

#include <math.h>

/* MAX17048 Register Addresses */
#define MAX17048_I2C_ADDR           0x36
#define MAX17048_VCELL_REG          0x02
#define MAX17048_SOC_REG            0x04
#define MAX17048_MODE_REG           0x06
#define MAX17048_VERSION_REG        0x08
#define MAX17048_CONFIG_REG         0x0C
#define MAX17048_COMMAND_REG        0xFE

/* Power Management Constants */
#define BATTERY_FULL_VOLTAGE_MV     4200    // 4.2V full charge
#define BATTERY_EMPTY_VOLTAGE_MV    3300    // 3.3V empty
#define LOW_BATTERY_THRESHOLD       15      // 15% SOC
#define CRITICAL_BATTERY_THRESHOLD  5       // 5% SOC
#define POWER_SAVE_THRESHOLD        20      // 20% SOC

/* Power Management State */
typedef struct {
    uint16_t battery_voltage_mv;
    uint8_t battery_soc_percent;
    bool charging_active;
    bool low_battery_warning;
    bool critical_battery_alert;
    uint32_t power_save_mode_time;
    uint32_t total_runtime_minutes;
    float average_power_consumption_mw;
} power_management_t;

/* Global Variables */
static power_management_t power_state;
static volatile bool power_management_initialized = false;
static uint32_t system_start_time;

/* Private Function Prototypes */
static fsp_err_t max17048_init(void);
static fsp_err_t max17048_read_voltage(uint16_t *voltage_mv);
static fsp_err_t max17048_read_soc(uint8_t *soc_percent);
static void enter_power_save_mode(void);
static void exit_power_save_mode(void);
static void update_power_statistics(void);

/**
 * @brief Initialize power management system
 */
fsp_err_t power_management_init(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Initialize I2C for MAX17048 */
    err = R_IIC_MASTER_Open(&g_i2c_master0_ctrl, &g_i2c_master0_cfg);
    if (FSP_SUCCESS != err) return err;

    /* Initialize MAX17048 fuel gauge */
    err = max17048_init();
    if (FSP_SUCCESS != err) return err;

    /* Initialize power state */
    memset(&power_state, 0, sizeof(power_state));
    system_start_time = R_FSP_SystemClockHzGet() / 1000;

    /* Initial battery reading */
    max17048_read_voltage(&power_state.battery_voltage_mv);
    max17048_read_soc(&power_state.battery_soc_percent);

    power_management_initialized = true;

    return FSP_SUCCESS;
}

/**
 * @brief Initialize MAX17048 fuel gauge
 */
static fsp_err_t max17048_init(void)
{
    fsp_err_t err;
    uint8_t tx_data[3];

    /* Reset MAX17048 */
    tx_data[0] = MAX17048_COMMAND_REG;
    tx_data[1] = 0x00; // Reset command high byte
    tx_data[2] = 0x54; // Reset command low byte

    err = R_IIC_MASTER_Write(&g_i2c_master0_ctrl, tx_data, 3, false);
    if (FSP_SUCCESS != err) return err;

    /* Wait for reset completion */
    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MILLISECONDS);

    /* Configure MAX17048 */
    tx_data[0] = MAX17048_CONFIG_REG;
    tx_data[1] = 0x97; // Alert threshold and configuration
    tx_data[2] = 0x00;

    err = R_IIC_MASTER_Write(&g_i2c_master0_ctrl, tx_data, 3, false);

    return err;
}

/**
 * @brief Read battery voltage from MAX17048
 */
static fsp_err_t max17048_read_voltage(uint16_t *voltage_mv)
{
    fsp_err_t err;
    uint8_t tx_data[1];
    uint8_t rx_data[2];

    /* Read VCELL register */
    tx_data[0] = MAX17048_VCELL_REG;

    err = R_IIC_MASTER_Write(&g_i2c_master0_ctrl, tx_data, 1, true);
    if (FSP_SUCCESS != err) return err;

    err = R_IIC_MASTER_Read(&g_i2c_master0_ctrl, rx_data, 2, false);
    if (FSP_SUCCESS != err) return err;

    /* Convert to millivolts (resolution: 1.25mV/LSB) */
    uint16_t raw_voltage = (rx_data[0] << 8) | rx_data[1];
    *voltage_mv = (uint16_t)((raw_voltage >> 4) * 1.25f);

    return FSP_SUCCESS;
}

/**
 * @brief Read state of charge from MAX17048
 */
static fsp_err_t max17048_read_soc(uint8_t *soc_percent)
{
    fsp_err_t err;
    uint8_t tx_data[1];
    uint8_t rx_data[2];

    /* Read SOC register */
    tx_data[0] = MAX17048_SOC_REG;

    err = R_IIC_MASTER_Write(&g_i2c_master0_ctrl, tx_data, 1, true);
    if (FSP_SUCCESS != err) return err;

    err = R_IIC_MASTER_Read(&g_i2c_master0_ctrl, rx_data, 2, false);
    if (FSP_SUCCESS != err) return err;

    /* Extract SOC percentage (high byte = integer part) */
    *soc_percent = rx_data[0];

    return FSP_SUCCESS;
}

/**
 * @brief Enter power save mode
 */
static void enter_power_save_mode(void)
{
    /* Reduce EEG sampling rate */
    // This would require coordination with EEG acquisition task

    /* Disable non-essential peripherals */
    // R_SPI_Close(&g_spi1_ctrl); // Close unused SPI
    // R_ADC_Close(&g_adc1_ctrl); // Close unused ADC

    /* Reduce CPU frequency */
    R_CGC_SystemClockSet(CGC_SYSTEM_CLOCK_MODE_LOW_SPEED);

    power_state.power_save_mode_time = R_FSP_SystemClockHzGet() / 1000;
}

/**
 * @brief Exit power save mode
 */
static void exit_power_save_mode(void)
{
    /* Restore CPU frequency */
    R_CGC_SystemClockSet(CGC_SYSTEM_CLOCK_MODE_HIGH_SPEED);

    /* Re-enable peripherals */
    // Re-initialization code here

    /* Update power save statistics */
    uint32_t current_time = R_FSP_SystemClockHzGet() / 1000;
    // power_save_duration = current_time - power_state.power_save_mode_time;
}

/**
 * @brief Update power consumption statistics
 */
static void update_power_statistics(void)
{
    uint32_t current_time = R_FSP_SystemClockHzGet() / 1000;
    power_state.total_runtime_minutes = (current_time - system_start_time) / 60000;

    /* Estimate power consumption based on voltage and current draw */
    /* This is simplified - actual implementation would measure current */
    float estimated_current_ma = 150.0f; // Approximate current draw
    power_state.average_power_consumption_mw =
        (power_state.battery_voltage_mv * estimated_current_ma) / 1000.0f;
}

/**
 * @brief Î¼T-Kernel Task: Power Management (1Hz)
 * Priority: 40 (Low priority background task)
 */
void task_power_management_entry(INT stacd, void *exinf)
{
    (void)stacd;
    (void)exinf;

    static bool power_save_active = false;

    /* Initialize power management */
    if (power_management_init() != FSP_SUCCESS) {
        while(1) tk_dly_tsk(1000);
    }

    while(1) {
        /* Read battery status */
        max17048_read_voltage(&power_state.battery_voltage_mv);
        max17048_read_soc(&power_state.battery_soc_percent);

        /* Check charging status */
        power_state.charging_active = (power_state.battery_voltage_mv > BATTERY_FULL_VOLTAGE_MV);

        /* Battery level management */
        if (power_state.battery_soc_percent <= CRITICAL_BATTERY_THRESHOLD) {
            power_state.critical_battery_alert = true;
            /* Could trigger emergency shutdown */

        } else if (power_state.battery_soc_percent <= LOW_BATTERY_THRESHOLD) {
            power_state.low_battery_warning = true;

        } else {
            power_state.low_battery_warning = false;
            power_state.critical_battery_alert = false;
        }

        /* Power save mode management */
        if (power_state.battery_soc_percent <= POWER_SAVE_THRESHOLD && !power_save_active) {
            enter_power_save_mode();
            power_save_active = true;

        } else if (power_state.battery_soc_percent > POWER_SAVE_THRESHOLD && power_save_active) {
            exit_power_save_mode();
            power_save_active = false;
        }

        /* Update statistics */
        update_power_statistics();

        /* Sleep for 1 second */
        tk_dly_tsk(1000);
    }
}

/**
 * @brief Get power management statistics
 */
fsp_err_t get_power_statistics(uint8_t *battery_soc, uint16_t *voltage_mv, bool *low_battery, float *power_mw)
{
    if (!power_management_initialized) return FSP_ERR_NOT_INITIALIZED;

    if (battery_soc) *battery_soc = power_state.battery_soc_percent;
    if (voltage_mv) *voltage_mv = power_state.battery_voltage_mv;
    if (low_battery) *low_battery = power_state.low_battery_warning;
    if (power_mw) *power_mw = power_state.average_power_consumption_mw;

    return FSP_SUCCESS;
}
